{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cocoon","text":"<p>Welcome to my blog. You'll find writeups and ideas here.</p>"},{"location":"#paranoidmoth","title":"paranoidmoth","text":"<p>I'm Francisco Santos, 24 years old. I'm a pentester at Devoteam Cybertrust. I love listening to music and playing some video-games.</p> <p>The nickname <code>paranoidmoth</code> is a reference to radiohead (paranoid android) mixed with a word I like.</p> <p></p>"},{"location":"writeups/","title":"Home","text":"<p>In this directory you will find my writeups for solved challenges.</p>"},{"location":"writeups/pentesterlab/CVE-2007-1860-Double-Encoding/","title":"Introduction","text":"<p>The following information explains how to solve the CVE-2007-1860 course. It's a free pentesterlab exercise.</p>"},{"location":"writeups/pentesterlab/CVE-2007-1860-Double-Encoding/#the-problem-with-tomcat","title":"The problem with tomcat","text":"<p>Linux/Unix systems cannot execute <code>tomcat</code> on port <code>80</code> without root permissions. Tomcat does not drop privilleges at startup. For tomcat to be available for most users, it needs to execute on port <code>80</code> or <code>443</code> for https. This leads to a possible solution.</p>"},{"location":"writeups/pentesterlab/CVE-2007-1860-Double-Encoding/#proxying-from-apache-to-tomcat","title":"Proxying from apache to tomcat","text":"<p>To make the tomcat instance available for most users, an apache instance executes on port <code>80</code> and proxies the traffic to tomcat running at a higher port.</p> <p>These two instances can execute on the same server or not.</p> <p>The apache instance decides if the request should be proxied to tomcat or not.</p> <p>It's important to figure out which instance handles the <code>HTTP</code> request url. You can discover this by forcing <code>404</code> pages. If the <code>404</code> page belongs to apache, the component is apache. If it's a tomcat <code>404</code> page, the component is tomcat</p>"},{"location":"writeups/pentesterlab/CVE-2007-1860-Double-Encoding/#the-problem-of-proxying-from-apache-to-tomcat","title":"The problem of proxying from apache to tomcat","text":"<p>Both web-servers url-decode the path provided by the user. If you send <code>%252e</code> as input, the apache server will decode it to <code>%2e</code>. If the url accessed is configured to be proxied to tomcat, tomcat receives the request and url-decodes the <code>%2e</code> to <code>.</code>.</p> <p>With this information, we can access the tomcat manager. </p>"},{"location":"writeups/pentesterlab/CVE-2007-1860-Double-Encoding/#poc","title":"PoC","text":"<ol> <li>Find a tomcat 404 page.</li> <li>Use that page to send a request to tomcat that traverses to the manager.</li> </ol> <p>The tomcat 404 page can be found at: <code>/examples/jsp</code>. The payload is: <code>https://vulnerable_host.com/examples/jsp/%252e%252e/%252e%252e/manager.html</code></p> <p>This http request forces the tomcat manager to traverse to <code>manager/html</code>. (Tomcat receives the request as <code>%2e</code> and decodes it to <code>.</code> before processing it).</p>"},{"location":"writeups/pentesterlab/CVE-2007-1860-Double-Encoding/#in-we-go","title":"In we go","text":"<p>This instance of tomcat uses the default credentials <code>admin:</code>. We can base64 encode this and send it as input through the <code>&lt;Authorization: Basic&gt;</code> HTTP header.</p> <p><code>Authorization: Basic YWRtaW46</code></p>"},{"location":"writeups/pentesterlab/CVE-2007-1860-Double-Encoding/#the-webshell","title":"The webshell","text":"<p>We can upload a <code>.war</code> file through the manager. There's a <code>war</code> webshell in github.</p> <p>We need to double-encode <code>..</code> again or we get a 404 page. Tomcat 7 enforces the jessionid is part of the url-path.</p>"},{"location":"writeups/pentesterlab/CVE-2007-1860-Double-Encoding/#poc_1","title":"PoC","text":"<p>Ensure the authorization header is set when issuing the requests</p> <ol> <li>Download the  <code>war</code> webshell from github</li> <li>Set intercept to on and deploy the <code>war</code> file. In BurpSuite, Replace the values within angle-brackets in the path below and ensure the <code>war</code> file upload request uses that path:     <code>/examples/jsp/%252e%252e/%252e%252e/manager/html/upload;jsessionid=&lt;replace with jsessionid value&gt;?org.apache.catalina.filters.CSRF_NONCE=&lt;replace with csrf token value&gt;</code></li> <li>Open the shell and run the required command to solve the lab.</li> <li>Access the webshell with the traversal trick: <code>/examples/jsp/%252e%252e/%252e%252e/&lt;webshell filename&gt;</code></li> </ol>"},{"location":"writeups/pentesterlab/CVE-2007-1860-Double-Encoding/#conclusion","title":"Conclusion","text":"<ul> <li>Double URL encoding can bypass restrictions if the payload is decoded twice (or recursively).</li> </ul>"},{"location":"writeups/pentesterlab/CVE-2007-1860-Double-Encoding/#concise-mindmap","title":"Concise Mindmap","text":""}]}